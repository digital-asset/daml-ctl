-- {-# LANGUAGE CPP #-}
-- #if __GLASGOW_HASKELL__ >= 702
-- {-# LANGUAGE Safe #-}
-- {-# LANGUAGE DeriveGeneric #-}
-- #endif
-- #if __GLASGOW_HASKELL__ >= 710 && __GLASGOW_HASKELL__ < 802
-- {-# LANGUAGE AutoDeriveTypeable #-}
-- #endif
-----------------------------------------------------------------------------
-- |
-- Module      :  Control.Monad.Trans.Maybe
-- Copyright   :  (c) 2007 Yitzak Gale, Eric Kidd
-- License     :  BSD-style (see the file LICENSE)
--
-- Maintainer  :  R.Paterson@city.ac.uk
-- Stability   :  experimental
-- Portability :  portable
--
-- The 'MaybeT' monad transformer extends a monad with the ability to exit
-- the computation without returning a value.
--
-- A sequence of actions produces a value only if all the actions in
-- the sequence do.  If one exits, the rest of the sequence is skipped
-- and the composite action exits.
--
-- For a variant allowing a range of exception values, see
-- "Control.Monad.Trans.Except".
-----------------------------------------------------------------------------

module Daml.Control.Monad.Trans.Optional (
    -- * The MaybeT monad transformer
    OptionalT(..),
    mapOptionalT,
    -- * Monad transformations
    hoistOptional,
    optionalToExceptT,
    exceptToOptionalT,
    -- * Lifting other operations
    -- liftCallCC,
    -- liftCatch,
    liftListen,
    liftPass,
  ) where

import Prelude hiding (mapA)
-- import Control.Monad.IO.Class
import Daml.Control.Monad.Signatures
import Daml.Control.Monad.Trans.Class
import Daml.Control.Monad.Trans.Except (ExceptT(..))
-- import Data.Functor.Classes
-- #if MIN_VERSION_base(4,12,0)
import Daml.Data.Functor.Contravariant (Contravariant, contramap)
-- #endif

-- import Control.Applicative
-- import Control.Monad (MonadPlus(mzero, mplus), liftM)
-- #if MIN_VERSION_base(4,9,0)
-- import qualified Control.Monad.Fail as Fail
-- #endif
-- import Control.Monad.Fix (MonadFix(mfix))
-- #if MIN_VERSION_base(4,4,0)
-- import Control.Monad.Zip (MonadZip(mzipWith))
-- #endif
-- import Data.Maybe (fromMaybe)
-- #if !(MIN_VERSION_base(4,8,0)) || defined(__MHS__)
import DA.Foldable (Foldable, foldMap)
import DA.Traversable (Traversable, mapA)
-- #endif
-- #if __GLASGOW_HASKELL__ >= 704
-- import GHC.Generics
-- #endif

-- | The parameterizable maybe monad, obtained by composing an arbitrary
-- monad with the 'Maybe' monad.
--
-- Computations are actions that may produce a value or exit.
--
-- The 'return' function yields a computation that produces that
-- value, while @>>=@ sequences two subcomputations, exiting if either
-- computation does.
newtype OptionalT m a = OptionalT { runOptionalT : m (Optional a) }
-- #if __GLASGOW_HASKELL__ >= 710
--     deriving (Generic, Generic1)
-- #elif __GLASGOW_HASKELL__ >= 704
--     deriving (Generic)
-- #endif

-- instance (Eq1 m) => Eq1 (MaybeT m) where
--     liftEq eq (MaybeT x) (MaybeT y) = liftEq (liftEq eq) x y
--     {-# INLINE liftEq #-}

-- instance (Ord1 m) => Ord1 (MaybeT m) where
--     liftCompare comp (MaybeT x) (MaybeT y) = liftCompare (liftCompare comp) x y
--     {-# INLINE liftCompare #-}

-- instance (Read1 m) => Read1 (MaybeT m) where
--     liftReadsPrec rp rl = readsData $
--         readsUnaryWith (liftReadsPrec rp' rl') "MaybeT" MaybeT
--       where
--         rp' = liftReadsPrec rp rl
--         rl' = liftReadList rp rl

-- instance (Show1 m) => Show1 (MaybeT m) where
--     liftShowsPrec sp sl d (MaybeT m) =
--         showsUnaryWith (liftShowsPrec sp' sl') "MaybeT" d m
--       where
--         sp' = liftShowsPrec sp sl
--         sl' = liftShowList sp sl

-- instance (Eq1 m, Eq a) => Eq (MaybeT m a) where (==) = eq1
-- instance (Ord1 m, Ord a) => Ord (MaybeT m a) where compare = compare1
-- instance (Read1 m, Read a) => Read (MaybeT m a) where readsPrec = readsPrec1
-- instance (Show1 m, Show a) => Show (MaybeT m a) where showsPrec = showsPrec1

-- | Transform the computation inside a @MaybeT@.
--
-- * @'runMaybeT' ('mapMaybeT' f m) = f ('runMaybeT' m)@
mapOptionalT : (m (Optional a) -> n (Optional b)) -> OptionalT m a -> OptionalT n b
mapOptionalT f = OptionalT . f . runOptionalT
{-# INLINE mapOptionalT #-}

-- | Convert a 'Maybe' computation to 'MaybeT'.
hoistOptional : (Applicative m) => Optional b -> OptionalT m b
hoistOptional = OptionalT . pure

-- | Convert a 'MaybeT' computation to 'ExceptT', with a default
-- exception value.
optionalToExceptT : (Functor m) => e -> OptionalT m a -> ExceptT e m a
optionalToExceptT e (OptionalT m) = ExceptT $ fmap (optional (Left e) Right) m
{-# INLINE optionalToExceptT #-}

-- | Convert a 'ExceptT' computation to 'MaybeT', discarding the
-- value of any exception.
exceptToOptionalT : (Functor m) => ExceptT e m a -> OptionalT m a
exceptToOptionalT (ExceptT m) = OptionalT $ fmap (either (const None) Some) m
{-# INLINE exceptToOptionalT #-}

instance (Functor m) => Functor (OptionalT m) where
    fmap f = mapOptionalT (fmap (fmap f))
    {-# INLINE fmap #-}

instance (Foldable f) => Foldable (OptionalT f) where
    foldMap f (OptionalT a) = foldMap (foldMap f) a
    {-# INLINE foldMap #-}

instance (Traversable f) => Traversable (OptionalT f) where
    mapA f (OptionalT a) = OptionalT <$> mapA (mapA f) a
    {-# INLINE mapA #-}

instance (Functor m, Action m) => Applicative (OptionalT m) where
    pure = OptionalT . return . Some
    {-# INLINE pure #-}
    mf <*> mx = OptionalT $ do
        mb_f <- runOptionalT mf
        case mb_f of
            None    -> return None
            Some f  -> do
                mb_x <- runOptionalT mx
                case mb_x of
                    None    -> return None
                    Some x  -> return (Some (f x))
    {-# INLINE (<*>) #-}
    m *> k = m >>= \_ -> k
    {-# INLINE (*>) #-}

-- instance (Functor m, Monad m) => Alternative (MaybeT m) where
--     empty = MaybeT (return None)
--     {-# INLINE empty #-}
--     x <|> y = MaybeT $ do
--         v <- runMaybeT x
--         case v of
--             Nothing -> runMaybeT y
--             Some _  -> return v
--     {-# INLINE (<|>) #-}

instance (Action m) => Action (OptionalT m) where
-- #if !(MIN_VERSION_base(4,8,0))
--     return = MaybeT . return . Some
--     {-# INLINE return #-}
-- #endif
    x >>= f = OptionalT $ do
        v <- runOptionalT x
        case v of
            None    -> return None
            Some y  -> runOptionalT (f y)
    {-# INLINE (>>=) #-}
-- #if !(MIN_VERSION_base(4,13,0))
--     fail _ = MaybeT (return None)
--     {-# INLINE fail #-}
-- #endif

-- #if MIN_VERSION_base(4,9,0)
instance (Action m) => ActionFail (OptionalT m) where
    fail _ = OptionalT (return None)
    {-# INLINE fail #-}
-- #endif

-- instance (Monad m) => MonadPlus (MaybeT m) where
--     mzero = MaybeT (return None)
--     {-# INLINE mzero #-}
--     mplus x y = MaybeT $ do
--         v <- runMaybeT x
--         case v of
--             None -> runMaybeT y
--             Some _  -> return v
--     {-# INLINE mplus #-}

-- instance (MonadFix m) => MonadFix (MaybeT m) where
--     mfix f = MaybeT (mfix (runMaybeT . f . fromMaybe bomb))
--       where bomb = error "mfix (MaybeT): inner computation returned None"
--     {-# INLINE mfix #-}

instance MonadTrans OptionalT where
    lift = OptionalT . fmap Some
    {-# INLINE lift #-}

-- instance (MonadIO m) => MonadIO (MaybeT m) where
--     liftIO = lift . liftIO
--     {-# INLINE liftIO #-}

-- #if MIN_VERSION_base(4,4,0)
-- instance (MonadZip m) => MonadZip (MaybeT m) where
--     mzipWith f (MaybeT a) (MaybeT b) = MaybeT $ mzipWith (liftA2 f) a b
--     {-# INLINE mzipWith #-}
-- #endif

-- #if MIN_VERSION_base(4,12,0)
instance Contravariant m => Contravariant (OptionalT m) where
    contramap f = OptionalT . contramap (fmap f) . runOptionalT
    {-# INLINE contramap #-}
-- #endif

-- | Lift a @callCC@ operation to the new monad.
-- liftCallCC : CallCC m (Maybe a) (Maybe b) -> CallCC (MaybeT m) a b
-- liftCallCC callCC f =
--     MaybeT $ callCC $ \ c -> runMaybeT (f (MaybeT . c . Some))
-- {-# INLINE liftCallCC #-}

-- | Lift a @catchE@ operation to the new monad.
-- liftCatch : Catch e m (Maybe a) -> Catch e (MaybeT m) a
-- liftCatch f m h = MaybeT $ f (runMaybeT m) (runMaybeT . h)
-- {-# INLINE liftCatch #-}

-- | Lift a @listen@ operation to the new monad.
liftListen : (Action m) => Listen w m (Optional a) -> Listen w (OptionalT m) a
liftListen listen = mapOptionalT $ \ m -> do
    (a, w) <- listen m
    return $ fmap (\ r -> (r, w)) a
{-# INLINE liftListen #-}

-- | Lift a @pass@ operation to the new monad.
liftPass : (Action m) => Pass w m (Optional a) -> Pass w (OptionalT m) a
liftPass pass = mapOptionalT $ \ m -> pass $ do
    a <- m
    return $ case a of
        None        -> (None, identity)
        Some (v, f) -> (Some v, f)
{-# INLINE liftPass #-}
